% Generated by Sphinx.
\def\sphinxdocclass{report}
\newif\ifsphinxKeepOldNames \sphinxKeepOldNamestrue
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage{iftex}

\ifPDFTeX
  \usepackage[utf8]{inputenc}
\fi
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}


\title{Tomography Documentation}
\date{Aug 12, 2016}
\release{0.1}
\author{Tjeerd Fokkens, Andreas Fognini,  Val Zwiller}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Introduction}
\label{intro:introduction}\label{intro::doc}\label{intro:welcome-to-tomography-s-documentation}
This implementation of the density matrix reconstruction follows closely the method described in  D. F. V. James et al. Phys. Rev. A, 64, 052312 (2001). We tried to keep the naming in the code as similar as possible to that reference.


\section{Measurement}
\label{intro:measurement}
To reconstruct the density matrix of a two qubit photonic system we need to perform 16 coincidence measurements between the two qubits in 16 different polarization projections.
A valid basis set for the reconstruction is for example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{basis} \PYG{o}{=}  \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HH}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HV}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{VV}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{VH}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HD}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HR}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{VD}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{VR}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DH}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DV}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DD}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DR}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{RH}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{RV}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{RD}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{RR}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\end{Verbatim}

In this example the first coincidence measurement is performed for the basis element ``HH''. This means that for both photons, the horizontal component of the polarization is measured.

In the second coincidence measurement, ``HV'', we measure the horizontal component of the first photon, and the vertical polarization component of the second one.


\section{Usage of the library}
\label{intro:usage-of-the-library}
Once all the coincidence counts have been collected the density matrix describing the quantum system can be reconstructed.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{Tomography} \PYG{k+kn}{import} \PYG{n}{DensityMatrix}

\PYG{n}{round\PYGZus{}digits} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{dm} \PYG{o}{=} \PYG{n}{DensityMatrix}\PYG{p}{(}\PYG{n}{basis}\PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HH}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HV}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{VV}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{VH}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{RH}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{RV}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DV}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DH}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DR}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DD}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{RD}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HD}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{VD}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{VL}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HL}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{RL}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

At first, the DensityMatrix class is initialized with the measurement basis. The measured correlation counts in this basis set is given to the function rho which calculates the density matrix.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Compute the raw density matrix, data from: D. F. V. James et al. Phys. Rev. A, 64, 052312 (2001).}
\PYG{n}{cnts} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{34749}\PYG{p}{,} \PYG{l+m+mi}{324}\PYG{p}{,} \PYG{l+m+mi}{35805}\PYG{p}{,} \PYG{l+m+mi}{444}\PYG{p}{,} \PYG{l+m+mi}{16324}\PYG{p}{,} \PYG{l+m+mi}{17521}\PYG{p}{,} \PYG{l+m+mi}{13441}\PYG{p}{,} \PYG{l+m+mi}{16901}\PYG{p}{,} \PYG{l+m+mi}{17932}\PYG{p}{,} \PYG{l+m+mi}{32028}\PYG{p}{,} \PYG{l+m+mi}{15132}\PYG{p}{,} \PYG{l+m+mi}{17238}\PYG{p}{,} \PYG{l+m+mi}{13171}\PYG{p}{,} \PYG{l+m+mi}{17170}\PYG{p}{,} \PYG{l+m+mi}{16722}\PYG{p}{,} \PYG{l+m+mi}{33586}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{rho}  \PYG{o}{=} \PYG{n}{dm}\PYG{o}{.}\PYG{n}{rho}\PYG{p}{(}\PYG{n}{cnts}\PYG{p}{)}
\end{Verbatim}

However, due to measurement imperfections this matrix is not necessarily positive semidefinite.
To circumvent this problem a maximum likelihood estimation as described in the aforementioned paper is implemented.
Please note that we initialize the t parameters in our implementation with only ones. In this way, the algorithm can also handle states like HH, since the Cholesky decomposition can effectively be computed.
We get the reconstructed positive semidefinite density matrix by evoking:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{rho\PYGZus{}recon} \PYG{o}{=} \PYG{n}{dm}\PYG{o}{.}\PYG{n}{rho\PYGZus{}max\PYGZus{}likelihood}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{,} \PYG{n}{cnts}\PYG{p}{)}
\end{Verbatim}

The library can also compute some quantum measures on the density matrix like the concurrence:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{concurrence} \PYG{o}{=} \PYG{n}{dm}\PYG{o}{.}\PYG{n}{concurrence}\PYG{p}{(}\PYG{n}{rho\PYGZus{}recon}\PYG{p}{)}
\end{Verbatim}

or the fidelity:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{n}{dm}\PYG{o}{.}\PYG{n}{fidelity\PYGZus{}max}\PYG{p}{(}\PYG{n}{rho\PYGZus{}recon}\PYG{p}{)}
\end{Verbatim}

The fidelity is calculated here to a maximally entangled state. We used the algorithm described in \url{http://dx.doi.org/10.1103/PhysRevA.66.022307}.

In quantum tomography not only the density matrix is of interest but also the pure state which most likely characterizes the system. This is only reasonable if the density matrix reconstructed is already close to a pure state, i.e. its fidelty or concurrence is close to unity.

The following code block is an example how to reconstruct a pure state with this library:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{closest\PYGZus{}state\PYGZus{}basis} \PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HH}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HV}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{VH}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{VV}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{closest\PYGZus{}state} \PYG{o}{=} \PYG{n}{dm}\PYG{o}{.}\PYG{n}{find\PYGZus{}closest\PYGZus{}pure\PYGZus{}state}\PYG{p}{(}\PYG{n}{rho\PYGZus{}recon}\PYG{p}{,} \PYG{n}{basis}\PYG{o}{=}\PYG{n}{closest\PYGZus{}state\PYGZus{}basis}\PYG{p}{)}

\PYG{n}{s} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{s} \PYG{o}{=} \PYG{n}{s} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{closest\PYGZus{}state}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{\textbar{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{closest\PYGZus{}state\PYGZus{}basis}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZgt{} + }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{n}{s} \PYG{o}{=} \PYG{n}{s} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{closest\PYGZus{}state}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{\textbar{}}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{closest\PYGZus{}state\PYGZus{}basis}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Closest State: }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{s} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}


\section{Error estimation}
\label{intro:error-estimation}
The error estimation is performed based on a Monte Carlo simulation. Each correlation count is assumed to be subjected to counting statistics. Thus, the measured number \(N\) of correlation counts will be replaced in each step of the simulation with a draw from a normal distribution with standard deviation \(\sigma=\sqrt{N}\) and mean \(\mu=N\).
In each simulation step a new density matrix is calculated.
Based on this set of simulated density matrices the standard deviation can be computed to estimate the error.

To get the error of the above examples do:

\begin{Verbatim}[commandchars=\\\{\}]
import numpy as np
from Tomography import Errorize
round\PYGZus{}digits = 2

basis= [\PYGZdq{}HH\PYGZdq{}, \PYGZdq{}HV\PYGZdq{},\PYGZdq{}VV\PYGZdq{},\PYGZdq{}VH\PYGZdq{},\PYGZdq{}RH\PYGZdq{},\PYGZdq{}RV\PYGZdq{},\PYGZdq{}DV\PYGZdq{},\PYGZdq{}DH\PYGZdq{},\PYGZdq{}DR\PYGZdq{},\PYGZdq{}DD\PYGZdq{},\PYGZdq{}RD\PYGZdq{},\PYGZdq{}HD\PYGZdq{},\PYGZdq{}VD\PYGZdq{},\PYGZdq{}VL\PYGZdq{},\PYGZdq{}HL\PYGZdq{},\PYGZdq{}RL\PYGZdq{}]
cnts = np.array([34749, 324, 35805, 444, 16324, 17521, 13441, 16901, 17932, 32028, 15132, 17238, 13171, 17170, 16722, 33586])
\PYGZsh{}Data from: D. F. V. James et al. Phys. Rev. A, 64, 052312 (2001).

err = Errorize(basis = basis, cnts = cnts)
err.multiprocessing\PYGZus{}simulate(n\PYGZus{}cycles\PYGZus{}per\PYGZus{}core  = 10, nbr\PYGZus{}of\PYGZus{}cores = 2)

rho\PYGZus{}err = err.rho\PYGZus{}max\PYGZus{}likelihood()

print(\PYGZdq{}Uncertainty of rho: \PYGZbs{}n\PYGZdq{} + str(np.around(rho\PYGZus{}err, decimals =round\PYGZus{}digits)) + \PYGZdq{}\PYGZbs{}n\PYGZdq{})

\PYGZsh{}Uncertainty of fidelity and concurrence estimates
fid\PYGZus{}err = err.fidelity\PYGZus{}max()
con\PYGZus{}err = err.concurrence()

print(\PYGZdq{}fid\PYGZus{}err: \PYGZbs{}n\PYGZdq{} + str(fid\PYGZus{}err) + \PYGZdq{}\PYGZbs{}n\PYGZdq{})
print(\PYGZdq{}con\PYGZus{}err: \PYGZbs{}n\PYGZdq{} + str(con\PYGZus{}err) + \PYGZdq{}\PYGZbs{}n\PYGZdq{})
\end{Verbatim}


\chapter{Installation}
\label{installation:installation}\label{installation::doc}
Before you start the installation of the library it is advised that you have installed numpy (numpy.org) and scipy (SciPy.org) packages already.

To install the library open a terminal and navigate into the Tomography folder.
Then install it either by:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{n}{install} \PYG{n}{setup}\PYG{o}{.}\PYG{n}{py}
\end{Verbatim}

Or by:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{python3} \PYG{n}{install} \PYG{n}{setup}\PYG{o}{.}\PYG{n}{py}
\end{Verbatim}

Depending on your python installation. Please note that this library needs python3.x .

You can test if the installation worked by importing the library:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{Tomography}
\end{Verbatim}

If you not getting an error message, everything works.


\chapter{Modules Description}
\label{modules:modules-description}\label{modules::doc}
In the following the Tomography module is described.
It consists of two classes:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{*} \PYG{n}{DensityMatrix}
\PYG{o}{*} \PYG{n}{Errorize}
\end{Verbatim}

The DensityMatrix class is used to calculate the density matrix, some quantum measures, and the pure state closest to the found density matrix. The Errorize class is used to compute uncertainties of the values computed in the DensityMatrix class by means of a Monte Carlo simulation.


\section{Tomography module}
\label{modules:tomography-module}\label{modules:module-Tomography}\index{Tomography (module)}\index{DensityMatrix (class in Tomography)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.DensityMatrix}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{Tomography.}\sphinxbfcode{DensityMatrix}}{\emph{basis}}{}
Bases: \sphinxcode{object}

Computes the density matrix for an optical two qubit system.
The measurements are performed with only one detector for each qubit.
The code is programmed along the procedure described in D. F. V. James et al. Phys. Rev. A, 64, 052312 (2001).

The measurements need to be performed in horizontal (H) or vertical (V),
circular right (R) or left (L), and diagonal (D) or antidiagonal (A) projections.
\begin{description}
\item[{We use the following vector representation:}] \leavevmode\begin{itemize}
\item {} 
\(H=\begin{pmatrix}1 \\ 0 \end{pmatrix}\)

\item {} 
\(V=\begin{pmatrix}0 \\ 1 \end{pmatrix}\)

\item {} 
\(R=\frac{1}{\sqrt{2}}\begin{pmatrix}1 \\ -i \end{pmatrix}\)

\item {} 
\(L=\frac{1}{\sqrt{2}}\begin{pmatrix}0 \\ i \end{pmatrix}\)

\item {} 
\(D=\frac{1}{\sqrt{2}}\begin{pmatrix}1 \\ 1 \end{pmatrix}\)

\item {} 
\(A=\frac{1}{\sqrt{2}}\begin{pmatrix}1 \\ -1 \end{pmatrix}\)

\end{itemize}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{basis}} (\emph{\texttt{array}}) -- An array of basis elements in which the measurement is performed.

\end{description}\end{quote}
\index{basis\_str\_to\_object() (Tomography.DensityMatrix method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.DensityMatrix.basis_str_to_object}\pysiglinewithargsret{\sphinxbfcode{basis\_str\_to\_object}}{\emph{pol='H'}}{}
Relate string of basis element to Stokes vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{pol}} (\emph{\texttt{str}}) -- String of the measurement basis. Valid elements H, V, R, L, D, A.

\item[{Returns}] \leavevmode
Stokes vector of the polarization specified by H, V, R, L, D, A.

\item[{Return type}] \leavevmode
numpy array

\end{description}\end{quote}

Example:
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
pol = \PYGZdq{}A\PYGZdq{}
\end{Verbatim}
\end{quote}

\end{fulllineitems}

\index{concurrence() (Tomography.DensityMatrix method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.DensityMatrix.concurrence}\pysiglinewithargsret{\sphinxbfcode{concurrence}}{\emph{rho}}{}
Compute the concurrence of the density matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{rho}} (\emph{\texttt{numpy\_array}}) -- Density matrix

\item[{Returns}] \leavevmode
The concurrence, see \url{https://en.wikipedia.org/wiki/Concurrence\_(quantum\_computing}).

\item[{Return type}] \leavevmode
complex

\end{description}\end{quote}

\end{fulllineitems}

\index{construct\_b\_matrix() (Tomography.DensityMatrix method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.DensityMatrix.construct_b_matrix}\pysiglinewithargsret{\sphinxbfcode{construct\_b\_matrix}}{\emph{PSI}, \emph{GAMMA}}{}
Construct B matrix as in D. F. V. James et al. Phys. Rev. A, 64, 052312 (2001).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{PSI}} (\emph{\texttt{array}}) -- \(\psi_\nu\) vector with \(\nu=1,...,16\), computed in \_\_init\_\_

\item {} 
\textbf{\texttt{GAMMA}} (\emph{\texttt{array}}) -- \(\Gamma\) matrices, computed in \_\_init\_\_

\end{itemize}

\item[{Returns}] \leavevmode
\(B_{\nu,\mu} = \langle \psi_\nu \rvert  \Gamma_\mu  \lvert \psi_\nu \rangle\)

\item[{Return type}] \leavevmode
numpy array

\end{description}\end{quote}

\end{fulllineitems}

\index{entropy\_neumann() (Tomography.DensityMatrix method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.DensityMatrix.entropy_neumann}\pysiglinewithargsret{\sphinxbfcode{entropy\_neumann}}{\emph{rho}}{}
Compute the von Neumann entropy of the density matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{rho}} (\emph{\texttt{numpy\_array}}) -- Density matrix

\item[{Returns}] \leavevmode
The von Neumann entropy of the density matrix. \(S=-\sum_{j}^{}m_j \mathrm{ln}(m_j)\), where \(m_j\) denotes the eigenvalues of rho.

\item[{Return type}] \leavevmode
complex

\end{description}\end{quote}

\end{fulllineitems}

\index{fidelity() (Tomography.DensityMatrix method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.DensityMatrix.fidelity}\pysiglinewithargsret{\sphinxbfcode{fidelity}}{\emph{m}, \emph{n}}{}
Compute the fidelity between the density matrces m and n.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{m}} (\emph{\texttt{numpy\_array}}) -- Density matrix

\item {} 
\textbf{\texttt{n}} (\emph{\texttt{numpy\_array}}) -- Density matrix

\end{itemize}

\item[{Returns}] \leavevmode
The fideltiy between m and n (\(\mathrm{Tr}(\sqrt{\sqrt{m}n\sqrt{m}})^2\)).

\item[{Return type}] \leavevmode
complex

\end{description}\end{quote}

\end{fulllineitems}

\index{fidelity\_max() (Tomography.DensityMatrix method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.DensityMatrix.fidelity_max}\pysiglinewithargsret{\sphinxbfcode{fidelity\_max}}{\emph{rho}}{}
Compute the maximal fidelity of rho to a maximally entangled state.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{rho}} (\emph{\texttt{numpy\_array}}) -- Density matrix

\item[{Returns}] \leavevmode

The maximal fidelity of rho \((\rho)\) to a maximally entangled state.
\(F(\rho)=\frac{1+\lambda_1+\lambda_2-\mathrm{sgn}(\mathrm{det(R)})\lambda_3}{4}\), where

\(R_{i,j}=\mathrm{Tr}(\sigma_i \otimes \sigma_j)\), with
\(\sigma_i, {i=1,2,3}\) the Pauli matrices and
\(\lambda_i, {i=1,2,3}\) the ordered singular values of R.

Note, the maximally entangled state is not computed.
Algorithm from: \url{http://dx.doi.org/10.1103/PhysRevA.66.022307}


\item[{Return type}] \leavevmode
complex

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_closest\_pure\_state() (Tomography.DensityMatrix method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.DensityMatrix.find_closest_pure_state}\pysiglinewithargsret{\sphinxbfcode{find\_closest\_pure\_state}}{\emph{rho, basis={[}'HH', `HV', `VH', `VV'{]}}}{}
Finds the closest pure state to the density matrix rho in the given basis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{rho}} (\emph{\texttt{numpy\_array}}) -- density matrix

\item {} 
\textbf{\texttt{basis}} (\emph{\texttt{array}}) -- The basis in which the state is described

\end{itemize}

\item[{Returns}] \leavevmode
state vector describing the closest pure state. By convention the first vector element has vanishing complex component.

\item[{Return type}] \leavevmode
numpy array

\end{description}\end{quote}

\end{fulllineitems}

\index{fun() (Tomography.DensityMatrix method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.DensityMatrix.fun}\pysiglinewithargsret{\sphinxbfcode{fun}}{\emph{t}, \emph{NormFactor}}{}
Maximum likelihood function to be minimized.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{t}} (\emph{\texttt{numpy\_array}}) -- t values.

\item {} 
\textbf{\texttt{NormFactor}} (\emph{\texttt{float}}) -- Normalization factor.

\end{itemize}

\item[{Returns}] \leavevmode
Function value. See for further information D. F. V. James et al. Phys. Rev. A, 64, 052312 (2001).

\item[{Return type}] \leavevmode
numpy float

\end{description}\end{quote}

\end{fulllineitems}

\index{opt\_pure\_state() (Tomography.DensityMatrix method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.DensityMatrix.opt_pure_state}\pysiglinewithargsret{\sphinxbfcode{opt\_pure\_state}}{\emph{coeff\_array}, \emph{rho}, \emph{basis}}{}
Helper function for \emph{self.find\_closest\_pure\_state}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{coeff\_array}} (\emph{\texttt{numpy\_array}}) -- Coefficient array, to be optimized

\item {} 
\textbf{\texttt{rho}} (\emph{\texttt{numpy\_array}}) -- Density matrix

\item {} 
\textbf{\texttt{basis}} -- The basis state from which the pure state is constructed, e.g. {[}''HH'', ``HV'', ``VH'', ``VV''{]}

\end{itemize}

\item[{Returns}] \leavevmode
1-fidelity, such that the minimizing function finds the maximum of the fidelity.

\item[{Return type}] \leavevmode
complex

\end{description}\end{quote}

\end{fulllineitems}

\index{purity() (Tomography.DensityMatrix method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.DensityMatrix.purity}\pysiglinewithargsret{\sphinxbfcode{purity}}{\emph{rho}}{}
Compute the purity of the density matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{rho}} (\emph{\texttt{numpy\_array}}) -- Density matrix

\item[{Returns}] \leavevmode
The density matrix's purity \(\mathrm{Tr}\rho^2\)

\item[{Return type}] \leavevmode
complex

\end{description}\end{quote}

\end{fulllineitems}

\index{rho() (Tomography.DensityMatrix method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.DensityMatrix.rho}\pysiglinewithargsret{\sphinxbfcode{rho}}{\emph{correlation\_counts}}{}
Compute the density matrix from measured correlation counts.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{correlation\_counts}} (\emph{\texttt{array}}) -- An array containing the correlation counts sorted according to the elements in self.basis.

\item[{Returns}] \leavevmode
The density matrix.

\item[{Return type}] \leavevmode
numpy array

\end{description}\end{quote}
\begin{description}
\item[{Example:}] \leavevmode
\begin{Verbatim}[commandchars=\\\{\}]
correlation\PYGZus{}counts = np.array([34749, 324, 35805, 444, 16324, 17521, 13441, 16901, 17932, 32028, 15132, 17238, 13171, 17170, 16722, 33586])
basis = [\PYGZdq{}HH\PYGZdq{},\PYGZdq{}HV\PYGZdq{},\PYGZdq{}VV\PYGZdq{},\PYGZdq{}VH\PYGZdq{},\PYGZdq{}RH\PYGZdq{},\PYGZdq{}RV\PYGZdq{},\PYGZdq{}DV\PYGZdq{},\PYGZdq{}DH\PYGZdq{},\PYGZdq{}DR\PYGZdq{},\PYGZdq{}DD\PYGZdq{},\PYGZdq{}RD\PYGZdq{},\PYGZdq{}HD\PYGZdq{},\PYGZdq{}VD\PYGZdq{},\PYGZdq{}VL\PYGZdq{},\PYGZdq{}HL\PYGZdq{},\PYGZdq{}RL\PYGZdq{}]
\end{Verbatim}

Data from: D. F. V. James et al. Phys. Rev. A, 64, 052312 (2001).

\end{description}

\end{fulllineitems}

\index{rho\_max\_likelihood() (Tomography.DensityMatrix method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.DensityMatrix.rho_max_likelihood}\pysiglinewithargsret{\sphinxbfcode{rho\_max\_likelihood}}{\emph{rho}, \emph{corr\_counts}}{}
Compute the density matrix based on the maximum likelihood approach.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{rho}} (\emph{\texttt{numpy\_array}}) -- Density matrix estimated from the measured correlation counts. Does not need to be physical, i.e. does not need to be postive semidefinite.

\item {} 
\textbf{\texttt{corr\_counts}} (\emph{\texttt{numpy\_array}}) -- Measured correlation counts corresponding to the basis specified in \_\_init\_\_.

\end{itemize}

\item[{Returns}] \leavevmode
Density matrix which is positive semidefinite.

\item[{Return type}] \leavevmode
numpy array

\end{description}\end{quote}

\end{fulllineitems}

\index{rho\_phys() (Tomography.DensityMatrix method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.DensityMatrix.rho_phys}\pysiglinewithargsret{\sphinxbfcode{rho\_phys}}{\emph{t}}{}
Positive semidefinite matrix based on t values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{t}} (\emph{\texttt{numpy\_array}}) -- tvalues

\item[{Returns}] \leavevmode
A positive semidefinite matrix which is an estimation of the actual density matrix.

\item[{Return type}] \leavevmode
numpy matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{rho\_state() (Tomography.DensityMatrix method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.DensityMatrix.rho_state}\pysiglinewithargsret{\sphinxbfcode{rho\_state}}{\emph{state}}{}
Compute the density matrix of a pure state.
The state is described by \(\psi_\nu\) elements.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{state}} -- The state expressed as a linear combination of \(\psi_\nu\) elements.

\item[{Returns}] \leavevmode
The corresponding density matrix.

\end{description}\end{quote}
\begin{description}
\item[{Example:}] \leavevmode
If the basis in \_\_init\_\_(basis) was chosen as:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{basis} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HH}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HV}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{VV}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{VH}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RH}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RV}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DV}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DH}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DR}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DD}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RD}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HD}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{VD}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{VL}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HL}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RL}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

The Bell state: \(\frac{1}{\sqrt{2}}(\lvert HH \rangle + i \lvert VV \rangle)\)

is described in python code with above basis as

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{state} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{PSI}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{1j}\PYG{o}{*}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{PSI}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\end{description}

\end{fulllineitems}

\index{rho\_state\_optimized() (Tomography.DensityMatrix method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.DensityMatrix.rho_state_optimized}\pysiglinewithargsret{\sphinxbfcode{rho\_state\_optimized}}{\emph{state}}{}
Compute the density matrix of a pure state based on the maximum likelihood approach.
Aim: To test the maximum likelihood function.
The state is described by \(\psi_\nu\) elements.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{state}} -- The state expressed as a linear combination of \(\psi_\nu\) elements.

\item[{Returns}] \leavevmode
The density matrix computed by the maximum likelihood approach.

\item[{Return type}] \leavevmode
numpy array

\end{description}\end{quote}
\begin{description}
\item[{Example:}] \leavevmode
If the basis in \_\_init\_\_(basis) was chosen as:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{basis} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HH}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HV}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{VV}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{VH}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RH}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RV}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DV}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DH}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DR}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DD}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RD}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HD}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{VD}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{VL}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HL}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RL}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

The Bell state: \(\frac{1}{\sqrt{2}}(\lvert HH \rangle + i \lvert VV \rangle)\) is described as:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{state} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{PSI}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{1j}\PYG{o}{*}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{PSI}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\end{description}

\end{fulllineitems}

\index{test\_gamma() (Tomography.DensityMatrix method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.DensityMatrix.test_gamma}\pysiglinewithargsret{\sphinxbfcode{test\_gamma}}{\emph{gamma}}{}
Test if \(\Gamma_i, {i=1,...,16}\) matrices are properly defined.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{GAMMA}} (\emph{\texttt{array}}) -- Gamma matrices.

\end{description}\end{quote}

Test for:
\begin{quote}

\(\mathrm{Tr}(\Gamma_i\Gamma_j)= \delta_{i,j}\)
\end{quote}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True if equation fullfilled for all gamma matrices, False otherwise.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Errorize (class in Tomography)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.Errorize}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{Tomography.}\sphinxbfcode{Errorize}}{\emph{basis}, \emph{cnts}}{}
Bases: {\hyperref[modules:Tomography.DensityMatrix]{\sphinxcrossref{\sphinxcode{Tomography.DensityMatrix}}}}

Compute +- uncertainty of the density matrix.
A Monte Carlo simulation is performed based on counting statistics.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{basis}} (\emph{\texttt{array}}) -- Basis of measurements

\item {} 
\textbf{\texttt{cnts}} (\emph{\texttt{array}}) -- Correlation counts of the measurements

\end{itemize}

\end{description}\end{quote}
\index{collect\_results() (Tomography.Errorize method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.Errorize.collect_results}\pysiglinewithargsret{\sphinxbfcode{collect\_results}}{\emph{result}}{}
Helper function for multicore processing.

\end{fulllineitems}

\index{complex\_std\_dev() (Tomography.Errorize method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.Errorize.complex_std_dev}\pysiglinewithargsret{\sphinxbfcode{complex\_std\_dev}}{\emph{matrices}}{}
Compute the standard deviation for the real and complex part of matrices separately.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{matrices}} (\emph{\texttt{numpy\_array}}) -- An array filled with matrices.

\item[{Returns}] \leavevmode
Standard deviation of the real and complex part for every matrix element.

\item[{Return type}] \leavevmode
complex

\end{description}\end{quote}

\end{fulllineitems}

\index{concurrence() (Tomography.Errorize method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.Errorize.concurrence}\pysiglinewithargsret{\sphinxbfcode{concurrence}}{}{}
Compute the standard deviation of the concurrence of density matrix.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Its standard deviation.

\end{description}\end{quote}

\end{fulllineitems}

\index{fidelity\_max() (Tomography.Errorize method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.Errorize.fidelity_max}\pysiglinewithargsret{\sphinxbfcode{fidelity\_max}}{}{}
Compute the standard deviation of the maximal fidelity of \(\rho\) to a maximally entangled state.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Its standard deviation.

\end{description}\end{quote}
\paragraph{Note, the maximally entangled state is not computed.
Function from: http://dx.doi.org/10.1103/PhysRevA.66.022307}

\end{fulllineitems}

\index{multiprocessing\_simulate() (Tomography.Errorize method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.Errorize.multiprocessing_simulate}\pysiglinewithargsret{\sphinxbfcode{multiprocessing\_simulate}}{\emph{n\_cycles\_per\_core=10}, \emph{nbr\_of\_cores=8}}{}
Perform Monte Carlo simulation parallel on several CPU cores. Each core will call function self.sim().
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{n\_cycles\_per\_core}} (\emph{\texttt{float}}) -- Number of simulations per core.

\item {} 
\textbf{\texttt{nbr\_of\_cores}} (\emph{\texttt{float}}) -- Number of CPUs

\end{itemize}

\item[{Returns}] \leavevmode
\begin{description}
\item[{self.rhos, self.rhosrec}] \leavevmode\begin{description}
\item[{self.rhos}] \leavevmode
array with raw density matrices and

\item[{self.rhosrec}] \leavevmode
array with maximum likelihood approximated matrices.

\end{description}

Note: `rhosrec' stands for rho reconstructed.

\end{description}
\begin{quote}\begin{description}
\item[{rtype}] \leavevmode
numpy matrices

\end{description}\end{quote}


\end{description}\end{quote}

\end{fulllineitems}

\index{purity() (Tomography.Errorize method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.Errorize.purity}\pysiglinewithargsret{\sphinxbfcode{purity}}{}{}
Compute the standard deviation of the density matrix's purity.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Its standard deviation.

\end{description}\end{quote}

\end{fulllineitems}

\index{rho() (Tomography.Errorize method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.Errorize.rho}\pysiglinewithargsret{\sphinxbfcode{rho}}{}{}
Compute the standard deviation of the density matrix.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Its standard deviation.

\end{description}\end{quote}

\end{fulllineitems}

\index{rho\_max\_likelihood() (Tomography.Errorize method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.Errorize.rho_max_likelihood}\pysiglinewithargsret{\sphinxbfcode{rho\_max\_likelihood}}{}{}
Compute the standard deviation of the density matrix reconstructed by the maximum likelihood method.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Its standard deviation.

\end{description}\end{quote}

\end{fulllineitems}

\index{sim() (Tomography.Errorize method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.Errorize.sim}\pysiglinewithargsret{\sphinxbfcode{sim}}{\emph{n\_cycles\_per\_core}, \emph{basis}}{}
Perform Monte Carlo simulation on one CPU.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{n\_cycles\_per\_core}} (\emph{\texttt{float}}) -- Number of simulations per core.

\item[{Returns}] \leavevmode
\begin{description}
\item[{a dictionary}] \leavevmode
\{`rhos': self.rhos, `rhosrec': self.rhosrec\} where

\item[{self.rhos}] \leavevmode
Array with raw density matrices.

\item[{self.rhosrec}] \leavevmode
Array with maximum likelihood approximated matrices.

\end{description}


\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{sim\_counts() (Tomography.Errorize method)}

\begin{fulllineitems}
\phantomsection\label{modules:Tomography.Errorize.sim_counts}\pysiglinewithargsret{\sphinxbfcode{sim\_counts}}{\emph{counts}}{}
Simulates counting statistics noise.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{counts}} (\emph{\texttt{numpy\_array}}) -- Measured counts.

\item[{Returns}] \leavevmode
Array of simulated counting statistics values.

\item[{Return type}] \leavevmode
numpy array

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{License}
\label{license::doc}\label{license:license}
The MIT License (MIT)

Copyright (c) 2016 Tjeerd Fokkens, Andreas Fognini, Val Zwiller

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ``Software''), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
